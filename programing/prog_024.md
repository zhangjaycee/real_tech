## Rust å­¦ä¹ ç¬”è®°

20190124


## 0.æ¦‚è¿°

Rustæ˜¯ç¼–è¯‘å‹è¯­è¨€ï¼Œrustcæ˜¯ç¼–è¯‘å™¨ï¼Œcargoæ˜¯é¡¹ç›®ç®¡ç†å·¥å…·ã€‚rustup docå¯ä»¥æŸ¥çœ‹æœ¬åœ°æ–‡æ¡£ã€‚

## 1. cargo

cargoæ¢æºï¼šhttps://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates

#### 1.1 Cargo.toml

cargoæœŸæœ›æºæ–‡ä»¶ä½äºsrcç›®å½•ã€‚cargoéœ€è¦ä¸€ä¸ªé…ç½®æ–‡ä»¶`Cargo.toml`ï¼Œtomlå³(Tom's Obvious, Minimal Language)ï¼Œæ ¼å¼ç±»ä¼¼äºiniæ–‡ä»¶ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```
[package]

name = "hello_world"
version = "0.0.1"
authors = ["jczhang <zhjcyx@gmail.com>"]
```

#### 1.2 å‘½ä»¤

å»ºå¥½Cargo.tomlæ–‡ä»¶ä¹‹åï¼Œå¯ä»¥ç”¨`cargo build`è¿›è¡Œç¨‹åºæ„å»ºã€‚ç”Ÿæˆçš„äºŒè¿›åˆ¶è·¯å¾„åº”è¯¥æ˜¯`target/debug/hello_world`ã€‚ä¹Ÿå¯ä»¥åˆå¹¶è¿™ä¸¤æ­¥ç›´æ¥ç”¨`cargo run`ç¼–è¯‘å’Œæ‰§è¡ŒäºŒè¿›åˆ¶ç¨‹åºã€‚æ³¨æ„ï¼Œè¿™æ ·ä½¿debugç‰ˆæœ¬ï¼Œå¦‚æœè¦ç”Ÿæˆreleaseç‰ˆæœ¬ï¼Œåº”è¯¥ç”¨`cargo build --release`,è¿™æ ·äºŒè¿›åˆ¶è·¯å¾„åº”è¯¥æ˜¯`target/release/hello_world`ã€‚Releaseç¼–è¯‘é€Ÿåº¦è¾ƒæ…¢ï¼Œä½†ç¨‹åºæ‰§è¡Œä¼šæ›´å¿«ã€‚

Cargoä¹Ÿæä¾›å»ºç«‹â€œéª¨æ¶é¡¹ç›®â€çš„å‘½ä»¤ï¼Œå¦‚ï¼š

```
cargo new hello_world
```

è¿™ä¸ªå‘½ä»¤ä¼šåˆ›å»ºä¸€ä¸ª`Cargo.toml`å’Œä¸€ä¸ªåŒ…å«`main.rs`çš„`srcç›®å½•`ã€‚`main.rs`å·²ç»å†™å¥½äº†ä¸€è¡Œ `println!("Hello, world!");` ä»£ç ï¼Œå¹¶ä¸”é¡¹ç›®ç›®å½•è¢«åˆ›å»ºå¥½äº†ä¸€ä¸ª**gitä»“åº“**ã€‚

`cargo check`å¯ä»¥æ£€æŸ¥æ˜¯å¦å¯ä»¥æ­£ç¡®ç¼–è¯‘è€Œä¸ç¼–è¯‘ï¼Œè¿™æ ·å¯ä»¥æ¯”buildæ›´å¿«åœ°æ£€æŸ¥è¯­æ³•é”™è¯¯ã€‚


## 2. æ‚é¡¹

#### 2.1 æ‰“å° println!

* ç”¨`println!`è¿›è¡Œæ‰“å°æ—¶ï¼Œå ä½ç¬¦æ˜¯`{}`ã€‚å…¶ä»–å’ŒCè¯­è¨€`printf`å¾ˆç±»ä¼¼ã€‚ä¾‹ï¼š

```rust
println!("x = {} and y = {}", x, y);
```

ä½†æ˜¯`{}`å¯¹åº”çš„æ˜¯structçš„`Display`æ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰ä¼španicï¼Œé‚£ä¹ˆå¾ˆå¤šæƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥ç”¨`{:?}`æˆ–è€…`{:#?}`ï¼Œå…¶å¯¹åº”å¯¹è±¡çš„`Debug`æ–¹æ³•ã€‚å…¶ä»–å ä½ç¬¦è¿˜æœ‰ï¼š

| å ä½ç¬¦ | å¯¹åº”æ–¹æ³• |
| ------ | -------- |
| ç©º     | Display  |
| ?      | Debug    |
| o      | Octal    |
| x      | LowerHex |
| X      | UpperHex |
| p      | Pointer  |
| b      | Binary   |
| e      | LowerExp |
| E      | UpperExp |

* crateæ˜¯rustçš„åº“æˆ–è€…äºŒè¿›åˆ¶ï¼Œåˆ†åˆ«ç§°ä¸ºåº“crateï¼Œæˆ–è€…äºŒè¿›åˆ¶crateã€‚crateä¸­åˆåŒ…å«æœ‰traitã€‚ è¿è¡Œ `cargo doc --open` å‘½ä»¤æ¥æ„å»ºæ‰€æœ‰æœ¬åœ°ä¾èµ–æä¾›çš„æ–‡æ¡£ï¼Œå¹¶åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ï¼Œè¿™æ ·å¯ä»¥ç¡®å®šåŒ…å«å“ªä¸ªtraitå’Œè°ƒç”¨å£°æ˜æ–¹æ³•ã€‚

```rust
use rand::Rng // randæ˜¯ä¸€ä¸ªåº“crateï¼ŒRngæ˜¯randçš„ä¸€ä¸ªtrait
```

#### 2.2 å…¶ä»–

- `//` è¡¨ç¤ºæ³¨é‡Šã€‚
- `use` å¼•å…¥åŒ…å«çš„åŒ…ã€‚
- ç¼©è¿›ç”¨**ç©ºæ ¼è€Œétab**ã€‚
- å£°æ˜ä¸€ä¸ªå˜é‡ç”¨`let`ï¼Œå¦‚ï¼š

```rust
let foo = 0;        // å¯å˜
let mut bar = 1;    // ä¸å¯å˜
let mut guess = String::new() // åˆ›å»ºå¯å˜å˜é‡ï¼Œå¹¶ç»‘å®šåˆ°æ–°çš„Stringç©ºå®ä¾‹ä¸Šã€‚
```

## 3. å˜é‡

#### 3.1 å¯å˜ï¼Œä¸å¯å˜å’Œå¸¸é‡

Rustçš„**å˜é‡**åˆ†ä¸ºå¯å˜(mutable)å’Œä¸å¯å˜(immutable)å˜é‡ï¼Œé»˜è®¤æ˜¯ä¸å¯å˜çš„ã€‚ä¸ä¸å¯å˜é‡ç±»ä¼¼çš„æ˜¯**å¸¸é‡**(const)ï¼Œä½†æ˜¯å¸¸é‡åªèƒ½ä»¥å¸¸é‡è¡¨è¾¾å¼åˆå§‹åŒ–ï¼Œå¹¶ä¸”éœ€è¦æŒ‡æ˜ç±»å‹ã€‚ä¾‹ï¼š


```rust
let x = 5;                          // ä¸å¯å˜é‡
let mut y = 6;                      // å¯å˜é‡   
const MAX_POINTS: u32 = 100_000;    // å¸¸é‡ï¼Œæ³¨æ„æ•°å­—ä¸­çš„ä¸‹åˆ’çº¿æ˜¯ä¸ºäº†å¯è¯»æ€§
```

#### 3.2 éšè— (Shadowing)

Rustä¸­å˜é‡å£°æ˜å¯ä»¥é‡åï¼Œå…ˆå£°æ˜çš„é‡ä¼šè¢«åå£°æ˜çš„åŒåé‡**éšè—** (Shadowing)ã€‚

åˆ©ç”¨â€œéšè—â€ï¼Œå¯ä»¥â€œæ”¹å˜â€ä¸å¯å˜é‡çš„å€¼ã€‚è¿™ç§æ”¹å˜æ–¹æ³•ï¼Œå…¶å®æ¯”æ”¹å˜å¯å˜é‡æ›´çµæ´»ï¼Œå› ä¸ºå®è´¨ä¸Šæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªåŒåä¸åŒç±»å‹çš„æ–°çš„ä¸å¯å˜é‡ï¼Œä¾‹å¦‚ï¼š

```rust
let spaces = "   ";
let spaces = spaces.len();
```

#### 3.3 æ•°æ®ç±»å‹

Rustæ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œå³ç¼–è¯‘æ—¶éœ€è¦ç¡®å®šæ‰€æœ‰å˜é‡çš„ç±»å‹ã€‚

* æ•´å½¢ï¼š

| é•¿åº¦(bits) | æœ‰ç¬¦å· | æ— ç¬¦å· |
| ---------- | ------ | ------ |
| 8          | i8     | u8     |
| 16         | i16    | u16    |
| 32         | i32    | u32    |
| 64         | i64    | u64    |
| arch       | isize  | usize  |

(å¯¹äºisize/usizeï¼Œè‹¥åœ¨64ä½æœºå™¨ä¸Šå³ä½¿64ä½ï¼Œå¦åˆ™ä¸º32ä½ã€‚)

* æ•´å½¢å­—é¢å€¼ï¼š


| æ•°å­—å­—é¢å€¼     | ä¾‹å­        |
| -------------- | ----------- |
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |


* æµ®ç‚¹å‹ï¼š

| é•¿åº¦(bit) | ç±»å‹ |
| --------- | ---- |
| 32        | f32  |
| 64        | f64  |

* å¸ƒå°”å‹ï¼š `bool`ï¼Œåªæœ‰ä¸¤ä¸ªå¯èƒ½å€¼ï¼š`true`å’Œ`false`

* å­—ç¬¦å‹ï¼š `char`ï¼Œ Rustä¸­çš„charå¹¶é1ä¸ªå­—èŠ‚ï¼Œå®ƒæ”¯æŒunicodeã€‚charå­—ç¬¦ç”¨å•å¼•å·åŒ…å›´ã€‚å¦‚ï¼š

```rust
let c = 'z';
let z = 'å“ˆ';
let heart_eyed_cat = 'ğŸ˜»';
```

#### 3.4. å¤åˆç±»å‹

Rust å¤åˆç±»å‹åŒ…æ‹¬tupleå’Œarrayï¼š

* tupleï¼š

```rust
// å£°æ˜tupleï¼š
let foo = (500, 6.4, 1);
let x: (i32, f64, u8) = (500, 6.4, 1);
// è§£æ„tuple:
let (x, y, z) = foo;
// ç´¢å¼•tupleï¼Œæ³¨æ„æ˜¯ç”¨â€œ.â€ è€Œéå¹¿æ³›ä½¿ç”¨çš„ä¸­æ‹¬å·
let five_hundred = x.0;
let one = x.2;
```

* Array

```rust
// å£°æ˜ä¸€ä¸ªæ•°ç»„
// æ³¨æ„ç±»å‹ååŠ åˆ†å·ï¼Œå†åŠ æ•°å­—ï¼Œè¿™é‡Œè¯´æ˜aæ•°ç»„åŒ…å«äº†5ä¸ªi32ç±»å‹çš„å…ƒç´ 
let a: [i32; 5] = [1, 2, 3, 4, 5];
// æ•°ç»„çš„ç´¢å¼•æ˜¯ç”¨ä¸­æ‹¬å· "[]"
let first = a[0];
```

æ³¨æ„ï¼šå¦‚æœç´¢å¼•è¶…å‡ºäº†æ•°ç»„é•¿åº¦ï¼ŒRust ä¼š panicï¼Œè¿™æ˜¯ Rust æœ¯è¯­ï¼Œå®ƒç”¨äºç¨‹åºå› ä¸ºé”™è¯¯è€Œé€€å‡ºçš„æƒ…å†µã€‚

## 4. å‡½æ•°

* å‡½æ•°å‚æ•°çš„ä¾‹å­ï¼š

```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

å’ŒC/C++ ä¸€æ ·ï¼Œå®šä¹‰å‡½æ•°æ—¶å¿…é¡»è¦æ³¨æ˜å‚æ•°ç±»å‹ã€‚

* å‡½æ•°è¿”å›çš„ä¾‹å­ï¼š

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

## 5. åˆ†æ”¯å’Œå¾ªç¯

åˆ†æ”¯ä¸»è¦æœ‰ifï¼Œå¾ªç¯ç»“æ„æœ‰loopã€forå’Œwhileã€‚

**if** ä¾‹1ï¼š

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

**if** ä¾‹2ï¼š

```rust
fn main() {
    let condition = true;
    // æ³¨æ„ï¼š è¿™ç§æƒ…å†µä¸‹ï¼Œå˜é‡å¿…é¡»åªæœ‰ä¸€ä¸ªç±»å‹
    // æ¯”å¦‚5å’Œ6è¿™é‡Œéƒ½æ˜¯i32ç±»å‹çš„
    let number = if condition {
        5
    } else {
        6
    };
    println!("The value of number is: {}", number);
}
```

**loop** ä¾‹1ï¼š

```rust
loop {
    println!("again!");
}
```

**loop** ä¾‹2ï¼š

```rust
let result = loop {
    counter += 1;

    if counter == 10 {
        break counter * 2;
    }
};
```

**while** ä¾‹ï¼š

```rust
while number != 0 {
    println!("{}!", number);

    number = number - 1;
}
```

**for** ä¾‹1ï¼š

```rust
let a = [10, 20, 30, 40, 50];
for element in a.iter() {
    println!("the value is: {}", element);
}
```

**for** ä¾‹2ï¼š

```rust
// rev å³åå‘
for number in (1..4).rev() {
    println!("{}!", number);
}
```

## 6. æ‰€æœ‰æƒç³»ç»Ÿ

æ‰€æœ‰æƒç³»ç»Ÿæ˜¯Rustä¸GCè¯­è¨€æˆ–æ‰‹åŠ¨å†…å­˜ç®¡ç†è¯­è¨€çš„ä¸»è¦åŒºåˆ«ã€‚

è·Ÿè¸ªå“ªéƒ¨åˆ†ä»£ç æ­£åœ¨ä½¿ç”¨**å †**ä¸Šçš„å“ªäº›æ•°æ®ï¼Œæœ€å¤§é™åº¦çš„å‡å°‘å †ä¸Šçš„é‡å¤æ•°æ®çš„æ•°é‡ï¼Œä»¥åŠæ¸…ç†å †ä¸Šä¸å†ä½¿ç”¨çš„æ•°æ®ç¡®ä¿ä¸ä¼šè€—å°½ç©ºé—´ï¼Œè¿™äº›é—®é¢˜æ­£æ˜¯æ‰€æœ‰æƒç³»ç»Ÿè¦å¤„ç†çš„ã€‚

å‡ ä¸ªæ‰€æœ‰æƒåŸºæœ¬è§„åˆ™ï¼š

```
Rust ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªè¢«ç§°ä¸ºå…¶ æ‰€æœ‰è€…ï¼ˆownerï¼‰çš„å˜é‡ã€‚
å€¼æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚
å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒã€‚
```

å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå­—é¢å€¼çš„å­—ç¬¦ä¸²æ˜¯ç›´æ¥ç¡¬ç¼–ç åˆ°ä»£ç ä¸­å¹¶å­˜åˆ°æ ˆä¸­çš„ï¼Œè€Œå¯å˜é•¿çš„Stringç±»å‹å¿…é¡»æ˜¯è¿è¡Œæ—¶ä»ç³»ç»Ÿåˆ†é…çš„å †ä¸­çš„å†…å­˜ï¼Œå¹¶ä¸”è¦åœ¨åˆé€‚çš„æ—¶å€™å°†å†…å­˜è¿”è¿˜ç»™æ“ä½œç³»ç»Ÿã€‚

Rust åœ¨å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å›æ”¶å†…å­˜ï¼Œå®ƒä¼šåœ¨`}`å¤„è‡ªåŠ¨è°ƒç”¨ä¸€ä¸ªç§°è°“dropçš„å‡½æ•°ã€‚

* å‚æ•°ä¼ é€’å’Œæ‰€æœ‰æƒ

åªè€ƒè™‘å †ä¸Šåˆ†é…å˜é‡çš„æƒ…å†µï¼Œæ¯”å¦‚å½“æŠŠä¸€ä¸ªå †ä¸Šå˜é‡xä»fooå‡½æ•°ä¼ ç»™ä¸€ä¸ªbarå‡½æ•°ï¼Œbarä¼šæ¥ç®¡xæ‰€æœ‰æƒï¼Œè¿™ä¸ªå˜é‡xä¹Ÿä¼šåœ¨è¢«è°ƒç”¨å‡½æ•°ç»“æŸæ—¶è¢«dropè°ƒï¼Œé™¤éå®ƒä»¥è¿”å›å€¼çš„å½¢å¼å†ä¼ å›ç»™fooã€‚ä¾‹ï¼š

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership å°†è¿”å›å€¼
                                        // ç§»ç»™ s1

    let s2 = String::from("hello");     // s2 è¿›å…¥ä½œç”¨åŸŸ

    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨åˆ°
                                        // takes_and_gives_back ä¸­, 
                                        // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {             // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™
                                             // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("hello"); // some_string è¿›å…¥ä½œç”¨åŸŸ.

    some_string                              // è¿”å› some_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ

    a_string  // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```

* å¼•ç”¨å’Œæ‰€æœ‰æƒå€Ÿå‡º

ä¸è¿‡ï¼Œè¿˜å¯ä»¥ç”¨å¼•ç”¨çš„å½¢å¼åœ¨ä¼ å‚çš„æ—¶å€™ä¸è½¬ç§»æ‰€æœ‰æƒï¼Œåªæ˜¯å°†å˜é‡å€Ÿå‡ºå»ï¼Œè¿™æ ·æ‰€æœ‰æƒåœ¨å‡½æ•°è¿”å›åä»ç„¶åœ¨ï¼Œxä¹Ÿæ²¡æœ‰è¢«baré‡Šæ”¾ã€‚ä½†æ˜¯æœ‰ä¸€ä¸ªå±€é™æ˜¯ï¼Œbarä¸­ä¸èƒ½æ›´æ”¹x(åªè¯»ï¼Ÿ)ã€‚å¼•ç”¨(`&`)å’Œè§£å¼•ç”¨(`*`)çš„ç¬¦å·å’ŒC++å¾ˆåƒï¼Œä½†æ³¨æ„ä¼ é€’ä¼ é€’å‘èµ·ç«¯ä¹Ÿè¦åŠ å¼•ç”¨ç¬¦å·`&`ã€‚ä¾‹ï¼š

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1); // è¿™é‡Œè¿”å›åï¼Œs1çš„æ‰€æœ‰æƒä»æ˜¯mainçš„

    println!("The length of '{}' is {}.", s1, len);
}
fn calculate_length(s: &String) -> usize {
    s.len()
} // è¿™é‡Œså¹¶ä¸ä¼šè¢«drop
```

è¦æƒ³è®©æ‰€å¼•ç”¨çš„å˜é‡åœ¨è¢«â€œå€Ÿå‡ºâ€è¿‡ç¨‹ä¸­å¯å˜ï¼Œè¿˜æ˜¯éœ€è¦åœ¨å‚æ•°åˆ—è¡¨ä¸­åŠ å…¥`mut`å…³é”®å­—(å³ç”¨`&mut`ä»£æ›¿`&`)ã€‚ä¾‹ï¼š

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s); // æ³¨æ„ï¼Œä¼ å‚æ˜¯ä¹Ÿè¦åŠ  &mut
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

è¿˜æœ‰ä¸€ä¸ªé™åˆ¶ï¼Œå¯¹äºåŒä¸€ä»½å †ä¸Šå˜é‡(æ•°æ®)ï¼Œåœ¨åŒä¸€ä½œç”¨åŸŸä¸­åªèƒ½ç”±å®ƒçš„ä¸€ä»½å¯å˜å¼•ç”¨ï¼Œæˆ–è€…å¤šä»½ä¸å¯å˜å¼•ç”¨ã€‚è¿™æ„Ÿè§‰ä¸Šå°±ç±»ä¼¼è¯»å†™é”ï¼Œå¯ä»¥æœ‰å¤šä¸ªè¯»é”è¢«åŒæ—¶æŒæœ‰ï¼Œè¯»å’Œå†™ä¸èƒ½åŒæ—¶æŒæœ‰ï¼Œå†™å’Œå†™ä¹Ÿä¸èƒ½ã€‚Rustæ­£æ˜¯åˆ©ç”¨äº†è¿™ä¸ªæ€æƒ³ï¼Œåœ¨ç¼–è¯‘æ—¶å°±é˜²æ­¢äº†å¯èƒ½çš„æ•°æ®ç«äº‰ã€‚

è¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒRustä¸å…è®¸ä»¥å¼•ç”¨ä½œä¸ºè¿”å›å€¼æ¥å¤–å€Ÿæ‰€æœ‰æƒï¼Œå› ä¸ºè¿”å›æ˜¯ç”Ÿå‘½å‘¨æœŸä¼šç»“æŸï¼Œè¿™å›é€ æˆdangling pointeræ‚¬åœæŒ‡é’ˆï¼ŒRustä¸å…è®¸è¿™æ ·ã€‚ä¾‹ï¼š

```rust
// é”™è¯¯çš„ï¼š
fn dangle() -> &String { // dangle è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¼•ç”¨
    let s = String::from("hello"); // s æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸²
    &s // è¿”å›å­—ç¬¦ä¸² s çš„å¼•ç”¨
} // è¿™é‡Œ s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚å…¶å†…å­˜è¢«é‡Šæ”¾ã€‚
  // å±é™©ï¼

// æ­£ç¡®çš„ï¼š
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}
```

* å¯¹äºå †ä¸­çš„å˜é‡å¦‚Stringï¼Œèµ‹å€¼åownershipä¼šè¢«è½¬ç§»ï¼Œè¿™æ ·é˜²æ­¢äº†**double free**é—®é¢˜ã€‚æ¯”å¦‚ä¸‹è¾¹çš„ä»£ç å°±æ˜¯é”™çš„ï¼Œå› ä¸ºs1è¢«è½¬ç§»åˆ°s2äº†ä¹‹åå°±ä¸èƒ½å†ç”¨äº†ã€‚

```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
```

ä¸ºäº†è¿›è¡ŒçœŸæ­£çš„æ‹·è´ï¼Œå¯ä»¥è°ƒç”¨å¾ˆå¤šå¯¹è±¡(åŒ…æ‹¬string)å®ç°çš„`clone`æ–¹æ³•ï¼š

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

è€Œæ ˆä¸­çš„int,charç­‰ç±»å‹çš„å˜é‡å¼€é”€æ¯”è¾ƒä½ï¼Œæ‰€ä»¥ä¼šæ‹·è´ï¼Œä¹Ÿä¸å­˜åœ¨ownershipè½¬ç§»çš„é—®é¢˜ï¼Œè¿™æ˜¯å› ä¸ºå®ƒä»¬å®ç°äº†`Copy` traitã€‚æ³¨æ„ï¼Œå®ç°äº†`Drop` traitçš„ç±»å‹æ— æ³•å®ç°`Copy` traitã€‚

* slice å±äºå¼•ç”¨ï¼Œä¹Ÿæ²¡æœ‰æ‰€æœ‰æƒ(ownership)ï¼š 

å’ŒPythonçš„sliceåˆ‡ç‰‡ç±»ä¼¼ï¼ŒStringã€æ•°ç»„ç­‰éƒ½æ”¯æŒåˆ‡ç‰‡ï¼Œè¯­æ³•æ˜¯`&foo[m..n]`æˆ–è€…`foo[m..=n]`ï¼Œåè€…åŒ…å«`n`ï¼Œè€Œå‰è€…åªåˆ°`n-1`ã€‚

slice å±äºå¼•ç”¨ï¼Œä¹Ÿæ˜¯æ²¡æœ‰æ‰€æœ‰æƒçš„ï¼Œå…¶å®å’Œæ™®é€šå¼•ç”¨çš„åŒºåˆ«åªæ˜¯sliceçš„èŒƒå›´å°äºæ•´ä½“çš„èŒƒå›´ã€‚

å­—ç¬¦ä¸²ç±»å‹`String`å¯¹åº”çš„åˆ‡ç‰‡å¼•ç”¨ç±»å‹ä¸º`&str`ï¼Œå­—é¢å€¼å…¶å®å°±æ˜¯`&str`ç±»å‹ï¼Œå­—é¢å€¼å’Œå­—ç¬¦ä¸²sliceéƒ½æ˜¯ä¸å¯å˜çš„ã€‚

æ•°ç»„æ¯”å¦‚i32æ•°ç»„æ‰€å¯¹åº”çš„åˆ‡ç‰‡ç±»å‹æ˜¯`&[i32]`ã€‚



#### 7.2 lifetimeæ ‡è®°

- å‡½æ•°å£°æ˜ä¸­å¼•ç”¨çš„lifetimeæ ‡è®°

å¦‚ä¸Šæ‰€è¿°ï¼Œè‹¥å‡½æ•°è¿”å›æ˜¯å¼•ç”¨ï¼Œä¸å¯èƒ½æ˜¯æ¥è‡ªå‡½æ•°å†…éƒ¨çš„"å¤–å€Ÿ"ï¼Œé‚£è¿”å›çš„å¼•ç”¨åªå¯èƒ½æ˜¯ä¼ è¾“å‚æ•°çš„å¼•ç”¨ä¹‹ä¸€ã€‚

ä½†æ˜¯rust çš„ lifetime checker åˆéœ€è¦çŸ¥é“è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ‰€ä»¥å°±éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ã€‚

å£°æ˜å‘¨æœŸæ ‡æ³¨åˆ°å¼•ç”¨çš„è¯­æ³•å¦‚ä¸‹ï¼š

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

å‡½æ•°å£°æ˜ä¸­çš„æ ‡æ³¨çš„ä¾‹å­å¦‚ä¸‹ï¼š

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

è¿™ç§æ ‡æ³¨çš„å¿…è¦æ€§å°±ç±»ä¼¼äºæ³›å‹çš„å‡½æ•°å®šä¹‰ï¼šæ³›å‹å‡½æ•°å¯èƒ½åº”ç”¨äºå„ç§ç±»å‹ï¼Œå‡½æ•°æ‰€è¿”å›å¼•ç”¨çš„lifetimeä¹Ÿå¯èƒ½ç¬¦åˆå„ç§è¾“å…¥å¼•ç”¨çš„å£°æ˜å‘¨æœŸ(è¿™é‡Œçš„ç¬¦åˆæŒ‡çš„æ˜¯æœ‰ç›¸åŒæ ‡è®°çš„æœ€å°lifetimeï¼Œæ¯”å¦‚è¿™é‡Œlonogestçš„è¿”å›å¼•ç”¨çš„lifetimeç­‰äºè°ƒç”¨longestå‡½æ•°çš„ä¼ å…¥å‚æ•°x, yçš„æœ€å°çš„lifetime)ã€‚

* structå£°æ˜ä¸­å¼•ç”¨çš„lifetimeæ ‡è®°

ä¾‹å­ï¼š

```rust
struct ImportantExcerpt<'a> {
	part: &'a str,
}
```

* ç¼–è¯‘å™¨çš„å¼•ç”¨lifetimeæ ‡è®°è‡ªåŠ¨æ¨æ–­

ç¼–è¯‘å™¨ä¼šéµå¾ª3æ¡è§„åˆ™æ¥æ¨æ–­ï¼Œæ¨æ–­åå¦‚æœè¿˜æœ‰é—®é¢˜å°±ä¼šæŠ¥é”™ï¼š

1. æ¯ä¸ªè¾“å…¥å‚æ•°éƒ½æœ‰è‡ªå·±çš„ lifetime æ ‡è®°ï¼Œæ¯”å¦‚`fn foo(x: &i32, y: &i32);`ä¼šè¢«æ¨æ–­ä¸º`fn foo<'a, 'b>(x: &'a i32, y: &'b i32);`ï¼›
2. å¦‚æœåªæœ‰1ä¸ªè¾“å…¥å‚æ•°ï¼Œé‚£ä¹ˆå°†æ‰€æœ‰è¾“å‡ºå‚æ•°æ ‡ä¸ºè¾“å…¥å‚æ•°çš„æ ‡è®°ï¼›

3. å¦‚æœå£°æ˜æ˜¯ä¸ªstructçš„æ–¹æ³•è€Œéä¸€ä¸ªæ™®é€šå‡½æ•°ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šæœ‰`&self`æˆ–`&mut self`ï¼Œè¿™ç§æƒ…å†µä¸‹è¾“å‡ºçš„lifetimeå‚æ•°éƒ½æ ‡ä¸ºå’Œ `self` ä¸€æ ·ã€‚

ç¬¬1ã€2æ¡è§„åˆ™åœ¨å¾ˆå¤šåªæœ‰1ä¸ªè¾“å…¥å¼•ç”¨ã€1ä¸ªæˆ–å¤šä¸ªè¾“å‡ºå¼•ç”¨çš„æƒ…å†µä¸‹å¾ˆæœ‰ç”¨ã€‚

ç¬¬3æ¡è§„åˆ™ï¼Œè®©æˆ‘ä»¬åœ¨å®šä¹‰struct åŠå…¶æ–¹æ³•æ—¶å¾ˆå°‘éœ€è¦æ‰‹åŠ¨æ ‡æ³¨lifetimesã€‚

é¦–å…ˆï¼Œä¸€èˆ¬æƒ…å†µä¸‹å’Œæ³›å‹å‚æ•°ç±»ä¼¼ï¼Œéœ€è¦åœ¨`impl`å’Œstructåå­—ä¹‹åå„æ ‡æ³¨ï¼Œå› ä¸ºæ ‡æ³¨ä¹Ÿæ˜¯è¿™ä¸ªstruct çš„ä¸€éƒ¨åˆ†ã€‚å¦‚ï¼š`impl<'a> ImportantExcerpt<'a> {...}`ã€‚ç„¶åï¼Œä¹‹åçš„methodä¸€èˆ¬ä¸ç”¨åŠ lifetime æ ‡è®°ï¼Œå› ä¸ºç¬¬ä¸‰æ¡è§„åˆ™ã€‚

* Result è¿”å›çš„lifetimeæ ‡è®°ï¼š

`Err`å¦‚æœæºå¸¦å­—ç¬¦ä¸²ï¼Œéœ€è¦æ ‡è®°ä¸º`'static`ï¼Œä¾‹ï¼š

```rust
pub fn new(args: &[String]) 
		-> Result<Config, &'static str> {
     	...
}
```



## 7. æ³›å‹ (generic data type)

(å¯¹åº”ä¹¦ä¸­ç¬¬10ç« )

æ³¨æ„æ³›å‹ç”±äºé¢å‘å¤šç§å¯èƒ½çš„ç±»å‹ï¼Œæ‰€ä»¥æœ‰äº›æ–¹æ³•ï¼Œç”šè‡³ä¾‹å¦‚æ¯”è¾ƒå¤§å°çš„`std::cmp::PartialOrd` trait éƒ½æ˜¯æ²¡æœ‰å®ç°çš„ï¼Œæ‰€ä»¥éœ€è¦æœ‰ "trait bounds" çš„æ¦‚å¿µã€‚

#### 7.1 æ³›å‹å‡½æ•°

æ¯”å¦‚ä¹¦ä¸­å¦‚ä¸‹ä¾‹å­ï¼š`largest` æ³›å‹å‡½æ•°æ¥æ”¶listçš„åˆ‡ç‰‡slice(ä¹Ÿå³sliceï¼Œå¦‚ç¬”è®°ç¬¬6èŠ‚æ‰€è¿°)ï¼Œmainä¸­ä¼ å…¥largestçš„æ˜¯listçš„å¼•ç”¨(ç­‰ä»·äºlistæ•´ä½“çš„sliceï¼Ÿ)ã€‚**ä½†æ˜¯è¿™é‡Œç¼–è¯‘ä¸èƒ½é€šè¿‡ï¼Œå› ä¸ºæ³›å‹å‡å®šä¸åªæ˜¯å½“å‰çš„`i32`å’Œ`char`å¯èƒ½è°ƒç”¨`>`æ¯”è¾ƒï¼Œè¿˜æœ‰å¾ˆå¤šç±»å‹æ²¡æœ‰æ¯”è¾ƒçš„traitã€‚**

```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];
 		for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
 		largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
 		let result = largest(&number_list);
    println!("The largest number is {}", result);
 		let char_list = vec!['y', 'm', 'a', 'q'];
 		let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

#### 7.2 æ³›å‹æ•°æ®ç»“æ„struct

ä¾‹å­å¦‚ä¸‹ï¼Œæ³¨æ„å¦‚æœå®šä¹‰ç›¸åº”structå˜é‡æ—¶ï¼ŒåŒä¸€ä¸ªæ³›å‹æ ‡è¯†ç¬¦åªèƒ½å®šä¹‰æˆåŒä¸€ç§å˜é‡ï¼Œæ‰€ä»¥è¿™é‡ŒåŒºåˆ†äº†`T`å’Œ`U`ã€‚

```rust
struct Point<T, U> {
    x: T,
    y: U,
}
 fn main() {
Â Â Â Â let both_integer = Point { x: 5, y: 10 };
Â Â Â Â let both_float = Point { x: 1.0, y: 4.0 };
Â Â Â Â let integer_and_float = Point { x: 5, y: 4.0 };
}
```

#### 7.3 æ³›å‹æšä¸¾enum

å¸¸è§çš„`Option`å’Œ`Result`å®šä¹‰å¦‚ä¸‹ï¼Œå®ƒä»¬éƒ½å¯ä»¥ç”¨`match`ç»“æ„è¿›è¡Œåˆ†æ”¯ï¼Œæˆ–è€…ç”¨æ›´ç®€æ´çš„`if let`è¯­æ³•ã€‚

```rust
enum Option<T> {
    Some(T),
    None,
}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

å…³äº`match`å’Œ`if let`ï¼Œä»¥ä¸‹ä¸¤ç§ç”¨æ³•ç­‰ä»·ï¼š

```rust
let some_u8_value = Some(0u8);
// ç”¨matchï¼š
match some_u8_value {
    Some(3) => println!("three"),
    _ => (),
}
// ç”¨ if let
if let Some(3) = some_u8_value {
    println!("three");
}
```



## 8. é”™è¯¯å¤„ç†

Rustä¸­ï¼Œé”™è¯¯å¤„ç†å¯ä»¥åˆ†ä¸ºä¸¤å¤§ç±»ï¼Œä¸å¯æ¢å¤çš„(unrecoverable)æˆ–è€…å¯æ¢å¤çš„(recoverable)ã€‚

#### 8.1 ä¸å¯æ¢å¤çš„panic

ä¸å¯æ¢å¤çš„å³panicï¼Œå®ƒè¿˜å¯ä»¥é€šè¿‡ä¸»åŠ¨è°ƒç”¨`panic!`å®æ¥è¿›è¡Œï¼Œå¹¶ä¸”å¯ä»¥ç”¨`RUST_BAKTRACE=1 cargo run`æ¥è¿›è¡Œåœ¨panicçš„æ—¶å€™è‡ªåŠ¨æ‰“å°å‡½æ•°è°ƒç”¨æ ˆã€‚

#### 8.2 å¯æ¢å¤çš„Result

å¯æ¢å¤çš„é”™è¯¯å¤„ç†ä¸€èˆ¬ç”¨`enum Result`è¿”å›ç»“æœï¼Œå¦‚ï¼š

```rust
use std::fs::File;
fn main() {
    let f = File::open("hello.txt");
 		let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("There was a problem opening the file: {:?}", error)
        },
    };
}
```

è¿™é‡Œç”¨`match`åˆ†æ”¯å°†opençš„Resultç±»å‹è¿”å›ç»“æœè§£ææˆfileæˆ–è€…errorå¯¹è±¡ï¼Œå¹¶ä¸”åœ¨errorçš„æƒ…å†µä¸‹ä¸»åŠ¨panic! (è¿™é‡Œåªæ˜¯æ²¡é€‰æ‹©è¿›è¡Œæ¢å¤)ã€‚

**Reusltçš„shortcuts**

Rustæœ‰å¾ˆå¤šå…³äºè¿™äº›é”™è¯¯çš„è¯­æ³•ç³–ï¼š

`.unwrap()`åœ¨Resultä¸º`Ok`æ˜¯ç›´æ¥è¿”å›`Ok`ä¸­çš„å€¼ï¼Œåœ¨`Err`æ—¶ç›´æ¥panicã€‚

`.expect("my err message ...")`å’Œunwrapå¾ˆåƒï¼Œåªæ˜¯å¤šäº†panicæ—¶çš„é”™è¯¯æç¤ºå­—ç¬¦ä¸²ã€‚

`.unwrap_or_else()`åœ¨Okæ—¶å’Œ`.unwrap()`ç›¸åŒï¼Œåœ¨Erræ—¶å…è®¸ä¸å¼•èµ·panicè€Œæ˜¯å…è®¸ç¨‹åºå‘˜è‡ªå®šä¹‰å¤„ç†é”™è¯¯ã€‚è‡ªå®šä¹‰çš„å½¢å¼æ˜¯é—­åŒ…`closure`ï¼Œä¾‹ï¼š

```rust
use std::process;
fn main() {
    let args: Vec<String> = env::args().collect();
  	let config = Config::new(&args).unwrap_or_else(|err| {
      		println!("Problem parsing arguments: {}", err);
      		process::exit(1);
		});
  	...
}
```



#### 8.3 é”™è¯¯ä¼ æ’­ "?"

`?`å¯ä»¥è·Ÿåœ¨è¢«è°ƒç”¨çš„å‡½æ•°/æ–¹æ³•åï¼Œå®ƒçš„ä½œç”¨çš„æ˜¯åœ¨Resultä¸º`Err` çš„æƒ…å†µä¸‹å°†é”™è¯¯ä¼ ç»™ä¸Šä¸€å±‚çš„è°ƒç”¨è€…ã€‚è¿™æ ·åšå¾ˆè‡ªç„¶æœ‰ä¸ªå‰æï¼šå½“å‰å‡½æ•°çš„è¿”å›å€¼ä¹Ÿä¸ºReuslt æšä¸¾ã€‚ä¾‹ï¼š

```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();
		File::open("hello.txt")?.read_to_string(&mut s)?;
		Ok(s)
}
```



## 9. æµ‹è¯•



#### 9.1 Rustçš„æµ‹è¯•æœºåˆ¶

ç±»ä¼¼`#[derive]`è¿™ä¸ªrustå±æ€§ï¼Œå†™æµ‹è¯•ä»£ç æ—¶åœ¨`fn`å‰éœ€è¦åŠ `#[test]`è¿™ä¸ªå±æ€§ã€‚rustä¸­ï¼Œå±æ€§å³ä»£ç çš„å…ƒæ•°æ®ã€‚è¿™æ ·`cargo test`çš„æ—¶å€™ä¼šè¿è¡Œæ ‡è®°æœ‰`test`çš„ä»£ç ã€‚

`assert!`å®åœ¨testä¸­å¾ˆå¸¸ç”¨ã€‚å®ƒä¸`==`ç»“åˆçš„"å‡çº§ç‰ˆ"å°è£…æœ‰`assert_eq!`å’Œ`assert_ne!`ã€‚`assert!`å®åŒæ ·æ¥æ”¶ç¬¬äºŒä¸ªä½œä¸ºæ ¼å¼å­—ç¬¦ä¸²è¾“å‡ºçš„å‚æ•°ã€‚

åœ¨`#[test]`å’Œæµ‹è¯•å‡½æ•°ä½“é—´åŠ ä¸Š`#[should_panic]`å¯ä»¥æµ‹è¯•åº”å½“panicçš„æƒ…å†µã€‚ä½†æ˜¯ï¼Œè¿™ä¸å¤ªç²¾ç¡®ï¼Œå› ä¸ºå®ƒçš„ç²¾åº¦åœ¨æµ‹è¯•å‡½æ•°çš„ç²’åº¦ï¼Œä¸ºäº†æ›´å‡†ç¡®åŠ å…¥äº†`expected`å‚æ•°ï¼Œå®ƒæŒ‡å®šçš„å­—ç¬¦ä¸²åº”è¯¥æ˜¯æ‰€æœŸæœ›panicçš„å­ä¸²æ‰ç®—æµ‹è¯•é€šè¿‡ï¼Œå¦‚ï¼š

```rust
impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 {
            panic!("Guess value must be greater than or equal to 1, got {}.",
                   value);
        } else if value > 100 {
            panic!("Guess value must be less than or equal to 100, got {}.",
                   value);
        }
 Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
		#[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

* testçº¿ç¨‹

Rust test é»˜è®¤å¤štestè¢«**å¤šçº¿ç¨‹**åˆ†åˆ«å¹¶è¡Œæ‰§è¡Œï¼ŒæŸä¸ªthreadæ­»äº†ï¼Œå°±è®¤ä¸ºæ˜¯å“ªä¸ªtestå¤±è´¥äº†ã€‚ç”±äºå¤šçº¿ç¨‹ï¼Œæ‰€ä»¥rustæµ‹è¯•æŒºå¿«çš„ï¼Œä½†æ˜¯è¦æ³¨æ„æµ‹è¯•å‡½æ•°é—´ä¸è¦ç”¨å…±äº«ç¯å¢ƒï¼Œæ¯”å¦‚å·¥ä½œæ–‡ä»¶æˆ–è€…å…±äº«ç¯å¢ƒå˜é‡ï¼Œæ‰€ä»¥å½“ä½ æƒ³æ§åˆ¶çº¿ç¨‹æ•°æ—¶å¯ä»¥ç”¨ `--test-threads`æ ‡å¿—ï¼š

```rust
cargo test -- --test-threads=1
```

è¿™æ ·ï¼Œè™½ç„¶testæ‰§è¡Œæ…¢äº†ï¼Œä½†æ˜¯å¤šä¸ªtestä¹‹é—´çœŸæ­£åšåˆ°äº†ä¸ç›¸äº’å½±å“ã€‚

* testå‡½æ•°è¾“å‡º

ç±»ä¼¼çš„ï¼Œ`â€”nocapture`å‚æ•°åˆ™å¯ä»¥æ”¾test ä¸­çš„stdoutçœŸæ­£å±•ç¤ºç»™æˆ‘ä»¬ï¼Œè€Œä¸æ˜¯é»˜è®¤åœ°è¢«cargo testéšè—èµ·ã€‚ä½†æ˜¯æ³¨æ„ç”±äºtestsæ˜¯å¹¶è¡Œæ‰§è¡Œï¼Œstdoutä¹Ÿå¯èƒ½äº’ç›¸äº¤é”™ã€‚

* åªæ‰§è¡Œéƒ¨åˆ†test

å¯ä»¥åœ¨`cargo test`åç›´æ¥è·Ÿè¦æ‰§è¡Œtestå‡½æ•°æ‰€åŒ…å«çš„å­ä¸²ã€‚

å¦‚æœæŸäº›æµ‹è¯•å¾ˆå°‘æ‰§è¡Œæˆ–è€…æ‰§è¡Œå¾ˆè´¹æ—¶é—´æ‰€ä»¥ä¸€èˆ¬ä¸æ‰§è¡Œï¼Œåº”è¯¥åœ¨`#[test]`å’Œæµ‹è¯•å‡½æ•°ä¸­é—´åŠ ä¸Š`#[ignore]`ï¼Œè¦æ‰§è¡Œæ—¶éœ€è¦ï¼š

```bash
cargo test -- --ignored
```



#### 9.2 å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

Rust ç¤¾åŒºå°†æµ‹è¯•åˆ†ä¸ºä¸¤å¤§ç±»ï¼š**å•å…ƒæµ‹è¯•** unit tests å’Œ **é›†æˆæµ‹è¯•** integration testsã€‚

* å•å…ƒæµ‹è¯•

rustçš„å•å…ƒæµ‹è¯•æ”¯æŒç§æœ‰å‡½æ•°çš„æµ‹è¯•ï¼Œå…¶è¢«æ”¾åˆ°æœ‰`#[cfg(test)]`æ ‡è¯†çš„test moduleé‡Œé¢ã€‚ä¾‹å­ï¼š

```rust
// src/lib.rs
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}
 fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

* é›†æˆæµ‹è¯•

è€Œé›†æˆæµ‹è¯•æŒ‡çš„æ˜¯åœ¨projectç›®å½•ä¸­ä¸`src`ç›®å½•å¹³çº§çš„`tests`ç›®å½•ï¼Œç›®å½•ä¸‹æœ‰å¤šä¸ªrsæ–‡ä»¶ï¼Œæ¯ä¸ªä»£è¡¨ä¸€ä¸ªé›†æˆæµ‹è¯•ã€‚é›†æˆæµ‹è¯•ä¸å•å…ƒæµ‹è¯•ä¸åŒï¼Œä¸ç”¨æŒ‡å®š`#[cfg(test)]`ï¼Œrustç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç¡®å®šï¼›å¿…é¡»è¦`extern crate XXX`ï¼Œå› ä¸º`tests`æ–‡ä»¶å¤¹ä¸­æ¯ä¸ªtestéƒ½æ˜¯å•ç‹¬çš„crateã€‚ä¾‹å­ï¼š

```rust
// tests/integration_test.rs 
extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
```

å¯ä»¥ç”¨`cargo test --test TEST_NAME`æ¥åªæµ‹`TEST_NAME.rs`è¿™ä¸ªé›†æˆæµ‹è¯•ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬çš„å¤šä¸ªæµ‹è¯•rsæ–‡ä»¶è¦å…±äº«ä¸€äº›ä»£ç ï¼Œæˆ‘ä»¬ä¸èƒ½å‘½åæˆç±»ä¼¼`tests/common.rs`è€Œåº”è¯¥åˆ›å»ºæˆ`tests/common/mod.rs`ï¼Œè¿™æ ·é¿å…rust å°† commonä¹Ÿå½“æˆä¸€ä¸ªæµ‹è¯•ï¼Œè¿™æ˜¯å› ä¸ºrust çš„é›†æˆæµ‹è¯•ä¸ä¼šå°†`tests`çš„å­ç›®å½•æºç å½“åšä¸€ä¸ªæµ‹è¯•ã€‚ä¾‹å­ï¼š

```rust
// tests/integration_test.rs 
extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```



**TDD (test-driven development)æ­¥éª¤**

1. æƒ³åˆ°ç„¶åå†™å‡ºä¸€ä¸ªè‚¯å®šä¼šå¤±è´¥çš„æµ‹è¯•
2. ä¿®æ”¹è¢«æµ‹è¯•ä»£ç ä½¿è¿™ä¸ªæµ‹è¯•é€šè¿‡
3. è°ƒæ•´ä»£ç ä½¿å®ƒå¯ä»¥ä¸€ç›´é€šè¿‡è¿™ä¸ªæµ‹è¯•
4. å›åˆ°ç¬¬ä¸€æ­¥



## 10. Project ç®¡ç†

#### 10.1 ä»€ä¹ˆåº”è¯¥æ”¾main.rs

ä¸€èˆ¬æ¯”è¾ƒå¤§çš„ç¨‹åºåº”è¯¥å°†ä¸»è¦é€»è¾‘æ”¾åˆ°`lib.rs`è€Œä¸æ˜¯`main.rs`ï¼Œ`main.rs`åªåº”è¯¥åŒ…æ‹¬ï¼š

* å‘½ä»¤è¡Œå‚æ•°è§£æ(å¤ªå¤æ‚çš„è¯ä¹Ÿè¦æ”¾lib.rs)
* å…¶ä»–çš„ä¸€äº›é…ç½®
* è°ƒç”¨`lib.rs`ä¸­çš„æŸäº›runè¿è¡Œå‡½æ•°
* å¤„ç†runè¿è¡Œå‡½æ•°çš„é”™è¯¯

`main.rs`å¤„ç†çš„å°‘æ˜¯å› ä¸ºæˆ‘ä»¬æ— æ³•å¯¹`main`å‡½æ•°è¿›è¡Œæµ‹è¯•ï¼Œæ‰€æœ‰çš„æµ‹è¯•éƒ½æ”¾åœ¨`lib.rs`äº†ã€‚æ ¹æœ¬ç›®çš„æ˜¯ä¿è¯mainä¸­çš„ä»£ç å¯ä»¥ç”¨äººçœ¼åˆ†è¾¨å‡ºå¯¹é”™ã€‚





## 11. å‡½æ•°å¼ç¼–ç¨‹

ï¼ˆrust book chapter 13ï¼‰

#### 11.1 é—­åŒ… closure

æ³¨æ„ï¼Œé—­åŒ…è™½ç„¶ä¸ç”¨åœ¨è¾“å…¥å˜é‡æ ‡æ˜å‚æ•°çš„ç±»å‹ï¼Œä½†æ˜¯ä¸èƒ½åœ¨åç»­ä½¿ç”¨æ—¶åœ¨ä¸€ç§ä»¥ä¸Šçš„ç±»å‹ä¸­ä½¿ç”¨ï¼Œè¿™æ˜¯å› ä¸ºæ¯ä¸ªclosureéƒ½æœ‰è‡ªå·±éšå«çš„ç±»å‹ï¼Œå½“æˆ‘ä»¬æƒ³æŠŠclosureæ”¾å…¥structæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿä¸€å®šè¦æ˜¾å¼æ ‡æ˜ç±»å‹ã€‚



## 12. æ™ºèƒ½æŒ‡é’ˆ

ï¼ˆrust book chapter 14ï¼‰

tbc

## 13. crate.io

ï¼ˆrust book chapter 15ï¼‰

tbc

## 14. å¹¶å‘å’Œå¤šçº¿ç¨‹ç¼–ç¨‹

ï¼ˆrust book chapter 16ï¼‰



#### 14.1 Rust çº¿ç¨‹

æœ‰äº›è¯­è¨€ä½¿ç”¨1ï¼š1çš„çº¿ç¨‹æ¨¡å‹ï¼Œæœ‰äº›ä½¿ç”¨Mï¼šNçš„ã€‚ä½¿ç”¨Mï¼šNçš„çº¿ç¨‹æ¨¡å‹éœ€è¦è¾ƒå¤šçš„ç¼–ç¨‹è¯­è¨€runtimeä»£ç æ”¯æŒã€‚ç”±äºRustä¸ºäº†ä¿è¯éšæ—¶å¯ä»¥è°ƒç”¨Cè¯­è¨€æ¥ä¿è¯é«˜æ€§èƒ½ï¼Œéœ€è¦ä½¿ç”¨å°runtimeï¼Œæ‰€ä»¥ç”¨äº†å’Œæ“ä½œç³»ç»Ÿçº¿ç¨‹1ï¼š1çš„çº¿ç¨‹æ¨¡å‹ã€‚

åˆ›å»ºä¸€ä¸ªçº¿ç¨‹éœ€è¦å‘`thread::spawn`å‡½æ•°ä¸­ä¼ å…¥ä¸€ä¸ªé—­åŒ…ï¼Œå¦‚ä¸‹æ˜¯ä¹¦ä¸­çš„ä¾‹å­ï¼š

```rust
// src/main.rs
use std::thread;
use std::time::Duration;
 fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });
 for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
   handle.join().unwrap();
}

Klabnik, Steve. The Rust Programming Language (p. 345). No Starch Press. Kindle ç‰ˆæœ¬. 
```

ä½†éœ€è¦æ³¨æ„ï¼Œåœ¨rustä¸­ï¼Œå¦‚ä¸»çº¿ç¨‹é€€å‡ºï¼Œå­çº¿ç¨‹ä¹Ÿä¼šé©¬ä¸Šé€€å‡ºã€‚ç”±äº`thread::spawn`çš„è¿”å›æ—¶æ˜¯ä¸€ä¸ª`JoinHandle`ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨`join`æ–¹æ³•ç­‰å¾…çº¿ç¨‹å®Œæˆï¼ˆ`handle.join().unwrap();`ï¼‰ã€‚

å¦‚æœspawnçº¿ç¨‹çš„é—­åŒ…ä»£ç ä¸­è¦ä½¿ç”¨ä¸»ç¨‹åºçš„å˜é‡ï¼Œç”±äºrustçš„æ‰€æœ‰æƒæœºåˆ¶ï¼Œéœ€è¦äº¤æ‰€æœ‰æƒè½¬ç§»åˆ°é—­åŒ…å†…ï¼Œæ–¹æ³•æ˜¯åœ¨`||`å‰åŠ `move`å…³é”®å­—ï¼š

```rust
thread::spawn(move || {
  											....
											});
```

#### 14.2 çº¿ç¨‹é€šä¿¡

* ä¾‹1ï¼šçº¿ç¨‹é—´æ¶ˆæ¯ä¼ é€’ï¼ˆchannelï¼‰é€šä¿¡

æ¯”å¦‚ä¹¦ä¸­ä¾‹å­è¯´æ˜äº†å¦‚ä½•moveå’Œchannelï¼ˆå…³äºchannelï¼Œgoè¯­è¨€æœ‰ç±»ä¼¼çš„æ¦‚å¿µï¼Œgoè¯­è¨€å¯¹çº¿ç¨‹é€šä¿¡çš„è§‚ç‚¹æ˜¯â€œDo not communicate by sharing memory; instead, share memory by communicating.â€ï¼‰æ¥å®ç°çº¿ç¨‹é—´é€šä¿¡ã€‚

```rust
use std::thread;
use std::sync::mpsc;
 fn main() {
    let (tx, rx) = mpsc::channel();
 		thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();         // å­çº¿ç¨‹å‘é€
      	// å­çº¿ç¨‹å‘é€valåï¼Œvalä¸èƒ½å†è¢«å­çº¿ç¨‹ä½¿ç”¨
    });
 		let received = rx.recv().unwrap(); // ä¸»çº¿ç¨‹æ¥æ”¶
   																		// é˜»å¡åˆ°æ¥æ”¶æˆåŠŸ
    println!("Got: {}", received);
}
```

ä¸Šè¿°ä»£ç ä¸­ï¼Œ`rx.recv()`ä¼šé˜»å¡åˆ°æ¶ˆæ¯æ¥æ”¶å®Œæˆï¼Œå¹¶è¿”å›`Result<T, E>`ï¼›ä¸ä¹‹å¯¹åº”çš„ï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨`rx.try_recv()`æ¥è¾¾åˆ°éé˜»å¡ç«‹å³è¿”å›çš„æ•ˆæœã€‚

è¿˜éœ€æ³¨æ„ï¼Œé™¤äº†ä¸»çº¿ç¨‹çš„å˜é‡å¯ä»¥ç”¨è¿‡é—­åŒ…å‰çš„`move`è½¬ç§»åˆ°å­çº¿ç¨‹ä¸­ï¼Œé€šè¿‡`send()`å‘é€çš„å˜é‡ä¹Ÿè¢«moveåˆ°äº†æ¥æ”¶æ–¹ï¼Œå› æ­¤ä»£ç ä¸­`val`ä¸èƒ½åœ¨è¢«`send`ä¹‹åè¢«è¯»å†™ã€‚

* ä¾‹2ï¼šçº¿ç¨‹é—´å…±äº«å†…å­˜é€šä¿¡

ä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ¶ˆæ¯ä¼ é€’é€šä¿¡å°±åƒæ˜¯å•æ‰€æœ‰æƒï¼Œå½“æ¶ˆæ¯è¢«å‘èµ°ä¹‹åå°±ä¸åº”åœ¨ä½¿ç”¨å®ƒã€‚ä¸Šä¾‹ä¹Ÿè¯´æ˜ï¼ŒRusté€šè¿‡ç¼–è¯‘å™¨å¯¹æ­¤ä½œå‡ºäº†é™åˆ¶ã€‚

è€Œå…±äº«å†…å­˜æ˜¯ä¸€ç§å¤šæ‰€æœ‰æƒå½¢å¼ï¼ŒåŒä¸€ç‰‡å†…å­˜å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹å¹¶å‘è¯»å†™ã€‚è¦è¾¾åˆ°å…±äº«æ•°æ®çš„ä¸´æ—¶ç‹¬å ï¼Œäººä»¬ä¸€èˆ¬ä½¿ç”¨Mutexï¼ˆmutaul exclusiveï¼‰é”ã€‚ä½†ç”±äºäº’æ–¥é‡çš„ç®¡ç†ååˆ†trickyï¼Œå› æ­¤å¾ˆå¤šäººçƒ­è¡·äºchannelã€‚ä¸è¿‡Rustçš„ç±»å‹ç³»ç»Ÿå’Œæ‰€æœ‰æƒè§„åˆ™å¯ä»¥é¿å…å¾ˆå¤šmutexç›¸å…³çš„é”™è¯¯ï¼š

#### 14.3. Syncå’ŒSend traits

ä¸Šè¿°å¤§éƒ¨åˆ†Rustå¹¶å‘éƒ½å®ç°äºåŸºç¡€åº“è€Œéè¯­è¨€å±‚é¢ï¼Œè€ŒSyncå’ŒSendè¿™ä¸¤ç§std::marker traitsæ˜¯å°‘æœ‰çš„é›†æˆäºRustè¯­è¨€çš„ä¸å¹¶å‘ç›¸å…³çš„æ¦‚å¿µã€‚

å®ç°`Send`è¿™ä¸€marker traitçš„ç±»å‹å…è®¸è¢«åœ¨çº¿ç¨‹ä¹‹é—´ä¼ é€ï¼Œå¤§å¤šæ•°Rustç±»å‹å®ç°äº†`Send`ã€‚ä½†åŒ…æ‹¬`Rc<T>`åœ¨å†…çš„å°‘æ•°ç±»å‹æ²¡æœ‰å®ç°`Send`ï¼Œå› æ­¤æ— æ³•åœ¨åˆ›å»ºçº¿ç¨‹æ—¶è¢«"move"åˆ°é—­åŒ…ä»£ç ä¸­ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œå¯¹äº`Rc><T>`ï¼Œéœ€è¦ç”¨æ”¯æŒå¹¶å‘çš„`Arc<T>`ä»£æ›¿ã€‚

`Sync`è¿™ä¸€marker traitæ„å‘³ç€ï¼šå¯¹äºä¸€ä¸ªå®ç°`Sync`çš„ç±»å‹ï¼Œå®ƒå¯ä»¥åœ¨å¤šä¸ªçº¿ç¨‹ä¸­è¢«å®‰å…¨åœ°å¼•ç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœç±»å‹`T`æ˜¯Syncï¼Œé‚£ä¹ˆ`&T`å°±æ˜¯Sendã€‚

å…¨ç”±Sendæ„æˆçš„ç±»å‹è¿˜æ˜¯Sendã€‚å…¨ç”±Syncæ„æˆçš„ç±»å‹è¿˜æ˜¯Syncã€‚æ‰‹åŠ¨å®ç°Sendå’ŒSyncéœ€è¦ä½¿ç”¨åˆ°unsafe Rust codeï¼Œä¸æ¨èã€‚



## 16. unsafe Rust

#### 16.1. Raw pointers

ä»å¼•ç”¨åˆ›å»ºimmutableå’Œmutableçš„raw pointerçš„ä¾‹å­å¦‚ä¸‹ï¼š

```rust
let mut num = 5;
 let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

ä»ç‰¹å®šå†…å­˜åœ°å€åˆ›å»ºimmutableå’Œmutableçš„raw pointerçš„ä¾‹å­å¦‚ä¸‹ï¼š

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

ä»å¼•ç”¨åˆ›å»ºå¯ä»¥ä¿è¯raw pointerçœŸçš„æŒ‡å‘å†…å®¹ï¼Œä½†æ˜¯åè€…ï¼ˆä»å†…å­˜åœ°å€åˆ›å»ºï¼‰æ— æ³•ä¿è¯ï¼Œå› ä¸ºç‰¹å®šåœ°å€å†…å®¹å¯èƒ½ä¼šè¢«ç¼–è¯‘å™¨ä¼˜åŒ–æ‰æˆ–è€…æ ¹è¢«å°±æ²¡æœ‰ã€‚

å®šä¹‰raw pointerå¹¶éunsafeï¼Œä½†æ˜¯å¯¹å®ƒä»¬çš„ä½¿ç”¨éœ€è¦åœ¨unsafeä»£ç å—è¿›è¡Œï¼š

```rust
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
 unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

